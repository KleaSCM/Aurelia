/**
 * System Integration Tests.
 *
 * Tests the complete system: CPU + Bus + RAM + Loader.
 * Verifies end-to-end program loading and execution using the Assembler.
 *
 * Author: KleaSCM
 * Email: KleaSCM@gmail.com
 */

#include "Bus/Bus.hpp"
#include "Cpu/Cpu.hpp"
#include "Memory/RamDevice.hpp"
#include "System/Loader.hpp"
#include "System/MemoryMap.hpp"
#include "Tools/Assembler/Encoder.hpp"
#include "Tools/Assembler/Lexer.hpp"
#include "Tools/Assembler/Parser.hpp"
#include "Tools/Assembler/Resolver.hpp"
#include <catch2/catch_test_macros.hpp>
#include <iostream>
#include <sstream>

using namespace Aurelia;
using namespace Aurelia::System;

namespace {

/**
 * @brief Helper to assemble source code into binary.
 *
 * Replicates the full Assembler pipeline:
 * Lexer -> Parser -> Resolver -> Encoder.
 *
 * @param Source Assembly source code.
 * @return std::vector<std::uint8_t> Machine code.
 */
std::vector<std::uint8_t> Assemble(const std::string &Source) {
  using namespace Aurelia::Tools::Assembler;

  // 1. Lexer
  Lexer lexer(Source);
  auto tokens = lexer.Tokenize();
  if (tokens.empty()) {
    std::cerr << "Assemble Error: Lexer produced no tokens\n";
    return {};
  }

  // 2. Parser
  Parser parser(tokens);
  if (!parser.Parse()) {
    std::cerr << "Assemble Error (Parser): " << parser.GetErrorMessage()
              << "\n";
    return {};
  }

  auto instructions = parser.GetInstructions();
  auto labels = parser.GetLabels();
  auto dataSegment = parser.GetDataSegment();

  // 3. Resolver
  Resolver resolver(instructions, labels);
  if (!resolver.Resolve()) {
    std::cerr << "Assemble Error (Resolver): " << resolver.GetErrorMessage()
              << "\n";
    return {};
  }

  // 4. Encoder
  Encoder encoder(instructions);
  if (!encoder.Encode()) {
    std::cerr << "Assemble Error (Encoder): " << encoder.GetErrorMessage()
              << "\n";
    return {};
  }

  // 5. Combine Text + Data
  auto binary = encoder.GetBinary();
  if (!dataSegment.empty()) {
    binary.insert(binary.end(), dataSegment.begin(), dataSegment.end());
  }

  return binary;
}

} // namespace

TEST_CASE("System - Integration: Basic Execution") {
  /**
   * TEST CASE: Basic Execution
   *
   * Verifies that the CPU can execute a simple program generated by the
   * Assembler. Program: MOV R0, #42; HALT
   */

  // Setup
  Bus::Bus bus;
  Memory::RamDevice ram(RamSize, 0);
  Cpu::Cpu cpu;

  bus.ConnectDevice(&ram);
  cpu.ConnectBus(&bus);

  // Assemble
  std::string source = "MOV R0, #42\nHALT";
  auto program = Assemble(source);

  // Load
  Loader loader(bus);
  REQUIRE(loader.LoadData(program, ResetVector));

  // Execute
  cpu.Reset(ResetVector);
  for (int i = 0; i < 100 && !cpu.IsHalted(); ++i) {
    cpu.OnTick();
    bus.OnTick();
  }

  // Verify
  REQUIRE(cpu.IsHalted());
  REQUIRE(cpu.GetRegister(Cpu::Register::R0) == 42);
}

TEST_CASE("System - Integration: Math Test") {
  /**
   * TEST CASE: Math Verification
   *
   * Validates ALU operations (ADD, SUB, LSL) via Assembly.
   * Logic:
   *   MOV R1, #10
   *   ADD R1, #20  (R1 = 30)
   *   LSL R1, #1   (R1 = 60)
   *   HALT
   */
  Bus::Bus bus;
  Memory::RamDevice ram(RamSize, 0);
  Cpu::Cpu cpu;

  bus.ConnectDevice(&ram);
  cpu.ConnectBus(&bus);

  std::string source = R"(
		MOV R1, #10
		MOV R2, #20
		ADD R1, R1, R2
		MOV R2, #1
		LSL R1, R1, R2
		HALT
	)";

  auto program = Assemble(source);
  Loader loader(bus);
  REQUIRE(loader.LoadData(program, ResetVector));

  cpu.Reset(ResetVector);
  for (int i = 0; i < 100 && !cpu.IsHalted(); ++i) {
    cpu.OnTick();
    bus.OnTick();
  }

  REQUIRE(cpu.IsHalted());
  REQUIRE(cpu.GetRegister(Cpu::Register::R1) == 60);
}

TEST_CASE("System - Integration: SSD Read/Write (Persistence)") {
  /**
   * TEST CASE: SSD Persistence
   *
   * Verifies MMIO Write and Read capabilities to the Storage mapping.
   * Mocking SSD with RamDevice for verifying CPU-Bus-MMIO path.
   * Logic:
   *   Construct Address 0xE0000000
   *   Write 0xDEADBEEF
   *   Clear Register
   *   Read back
   */
  Bus::Bus bus;
  Memory::RamDevice ram(RamSize, 0);
  // Mock SSD at StorageControllerBase (0xE0000000)
  Memory::RamDevice ssd(0x1000, 0);
  ssd.SetBaseAddress(StorageControllerBase);

  bus.ConnectDevice(&ram);
  bus.ConnectDevice(&ssd);
  Cpu::Cpu cpu;
  cpu.ConnectBus(&bus);

  // ASM: Construct 0xE0000000 in R1
  // 0xE0 = 224
  std::string source = R"(
		MOV R1, #224
		MOV R3, #24
		LSL R1, R1, R3
		
		MOV R2, #123
		STR R2, [R1, #0]
		
		MOV R2, #0
		LDR R2, [R1, #0]
		
		HALT
	)";

  auto program = Assemble(source);
  Loader loader(bus);
  REQUIRE(loader.LoadData(program, ResetVector));

  cpu.Reset(ResetVector);
  for (int i = 0; i < 100 && !cpu.IsHalted(); ++i) {
    cpu.OnTick();
    bus.OnTick();
  }

  REQUIRE(cpu.IsHalted());

  // Verify Register Roundtrip
  REQUIRE(cpu.GetRegister(Cpu::Register::R2) == 123);

  // Verify "Persistence" in Device
  Core::Data val = 0;
  ssd.OnRead(StorageControllerBase, val);
  REQUIRE(val == 123);
}

TEST_CASE("System - Integration: Hello World (UART)") {
  /**
   * TEST CASE: UART Output
   *
   * Verifies ability to write to UART MMIO address.
   * Logic:
   *   Construct Address 0xE0001000 (UART)
   *   Write 'H' (72)
   *   HALT
   */
  Bus::Bus bus;
  Memory::RamDevice ram(RamSize, 0);
  // Mock UART using RamDevice to verify write (simplifies capturing output)
  // or we use valid address and ensure no bus error.
  Memory::RamDevice uartMock(0x1000, 0);
  uartMock.SetBaseAddress(UartBase);

  bus.ConnectDevice(&ram);
  bus.ConnectDevice(&uartMock);
  Cpu::Cpu cpu;
  cpu.ConnectBus(&bus);

  // ASM: Construct 0xE0001000 in R1
  // 0xE0000000 | 0x1000
  std::string source = R"(
		MOV R1, #224
		MOV R3, #24
		LSL R1, R1, R3
		
		MOV R2, #16
		MOV R3, #8
		LSL R2, R2, R3
		
		ADD R1, R1, R2
		
		MOV R0, #72
		STR R0, [R1, #0]
		HALT
	)";

  auto program = Assemble(source);
  Loader loader(bus);
  REQUIRE(loader.LoadData(program, ResetVector));

  cpu.Reset(ResetVector);
  for (int i = 0; i < 100 && !cpu.IsHalted(); ++i) {
    cpu.OnTick();
    bus.OnTick();
  }

  REQUIRE(cpu.IsHalted());

  // Verify Write to UART Mock
  Core::Data charWritten = 0;
  uartMock.OnRead(UartBase, charWritten);
  REQUIRE(charWritten == 72); // 'H'
}

TEST_CASE("Loader - File Not Found") {
  Bus::Bus bus;
  Loader loader(bus);

  REQUIRE_FALSE(loader.LoadBinary("nonexistent.bin"));
  REQUIRE(!loader.GetErrorMessage().empty());
}

TEST_CASE("Loader - Empty Data") {
  Bus::Bus bus;
  Loader loader(bus);

  std::vector<std::uint8_t> empty;
  REQUIRE_FALSE(loader.LoadData(empty, 0x0));
}

TEST_CASE("Loader - Address Out of Range") {
  Bus::Bus bus;
  Loader loader(bus);

  std::vector<std::uint8_t> data = {0x00, 0x00, 0x00, 0x00};

  // Try to load into MMIO space (should fail)
  REQUIRE_FALSE(loader.LoadData(data, MmioBase));
  REQUIRE(!loader.GetErrorMessage().empty());
}

TEST_CASE("MemoryMap - Address Validation") {
  // RAM addresses
  REQUIRE(IsRamAddress(RamBase));
  REQUIRE(IsRamAddress(RamEnd));
  REQUIRE(IsRamAddress(0x1000));

  // MMIO addresses
  REQUIRE(IsMmioAddress(MmioBase));
  REQUIRE(IsMmioAddress(StorageControllerBase));

  // RAM is not MMIO
  REQUIRE_FALSE(IsMmioAddress(0x1000));

  // MMIO is not RAM
  REQUIRE_FALSE(IsRamAddress(MmioBase));
}
